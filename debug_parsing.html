<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Parsing</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-output {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Debug Parsing</h1>
        
        <button onclick="debugParsing()">Debug 2 + 3 * 4</button>
        <div id="output" class="test-output"></div>
    </div>

    <script type="module">
        import { InteractionNet, AgentType, PortType } from './src/core/interaction_net.js';
        import { NetParser, parseZappToNet, tokenizeZapp } from './src/core/net_parser.js';
        
        window.debugParsing = function() {
            const output = document.getElementById('output');
            output.innerHTML = 'Debugging parsing of: 2 + 3 * 4\n\n';
            
            try {
                // Tokenize
                const sourceCode = '2 + 3 * 4';
                output.innerHTML += `üìù Source: ${sourceCode}\n`;
                
                const tokens = tokenizeZapp(sourceCode);
                output.innerHTML += `‚úì Generated ${tokens.length} tokens:\n`;
                tokens.forEach((token, i) => {
                    output.innerHTML += `  ${i}: type="${token.type}", value="${token.value}"\n`;
                });
                output.innerHTML += '\n';
                
                // Check arithmetic expression detection
                const parser = new NetParser();
                output.innerHTML += `üîç isArithmeticExpression(0): ${parser.isArithmeticExpression(tokens, 0)}\n`;
                output.innerHTML += `üîç isBinaryOperator(1): ${parser.isBinaryOperator(tokens, 1)}\n`;
                output.innerHTML += `üîç isBinaryOperator(3): ${parser.isBinaryOperator(tokens, 3)}\n\n`;
                
                // Parse
                output.innerHTML += 'üï∏Ô∏è Parsing...\n';
                const net = parser.parse(tokens);
                
                output.innerHTML += `‚úì Created net with ${net.agents.size} agents\n\n`;
                
                // Show agents
                output.innerHTML += 'üìã Agents created:\n';
                for (const agent of net.agents.values()) {
                    const typeName = getAgentTypeName(agent.type);
                    const dataStr = agent.data !== null ? `(${agent.data})` : '';
                    output.innerHTML += `  Agent ${agent.id}: ${typeName}${dataStr}\n`;
                    
                    // Show connections
                    agent.getAllPorts().forEach(port => {
                        if (port.isConnected()) {
                            const connectedAgent = port.getConnectedAgent();
                            const portType = port.type === 0 ? 'PRINCIPAL' : `AUX[${port.index}]`;
                            output.innerHTML += `    ${portType} ‚Üí Agent ${connectedAgent.id}\n`;
                        }
                    });
                }
                
                output.innerHTML += '\n';
                
                // Find active pairs
                const activePairs = net.findActivePairs();
                output.innerHTML += `üîç Found ${activePairs.length} active pairs\n`;
                
                if (activePairs.length > 0) {
                    output.innerHTML += '\nActive pairs:\n';
                    activePairs.forEach((pair, i) => {
                        if (pair.type === 'arithmetic') {
                            const type1 = getAgentTypeName(pair.agent1.type);
                            const type2 = getAgentTypeName(pair.agent2.type);
                            const type3 = getAgentTypeName(pair.agent3.type);
                            output.innerHTML += `  ${i + 1}. ${type1}(${pair.agent1.data}) with ${type2}(${pair.agent2.data}) and ${type3}(${pair.agent3.data}) [ARITHMETIC]\n`;
                        } else {
                            const type1 = getAgentTypeName(pair.agent1.type);
                            const type2 = getAgentTypeName(pair.agent2.type);
                            output.innerHTML += `  ${i + 1}. ${type1} ‚Üî ${type2} [PRINCIPAL]\n`;
                        }
                    });
                }
                
                // Test reduction
                output.innerHTML += '\n‚ö° Testing reduction...\n';
                const result = net.reduceToNormalForm(10);
                output.innerHTML += `‚úì Reduction completed in ${result.steps} steps\n`;
                output.innerHTML += `‚úì Normal form: ${result.normalForm ? 'Yes' : 'No'}\n`;
                output.innerHTML += `‚úì Final agents: ${result.finalAgents}\n\n`;
                
                // Show final state
                output.innerHTML += 'üìã Final agents:\n';
                for (const agent of net.agents.values()) {
                    const typeName = getAgentTypeName(agent.type);
                    const dataStr = agent.data !== null ? `(${agent.data})` : '';
                    output.innerHTML += `  Agent ${agent.id}: ${typeName}${dataStr}\n`;
                    
                    // Show connections
                    agent.getAllPorts().forEach(port => {
                        if (port.isConnected()) {
                            const connectedAgent = port.getConnectedAgent();
                            const portType = port.type === 0 ? 'PRINCIPAL' : `AUX[${port.index}]`;
                            output.innerHTML += `    ${portType} ‚Üí Agent ${connectedAgent.id}\n`;
                        }
                    });
                }
                
                // Show computed result
                if (net.agents.size === 1) {
                    const finalAgent = Array.from(net.agents.values())[0];
                    if (finalAgent.type === AgentType.NUM) {
                        output.innerHTML += `\nüéØ Final result: ${finalAgent.data}\n`;
                    }
                }
                
            } catch (error) {
                output.innerHTML += `‚ùå Error: ${error.message}\n`;
                output.innerHTML += error.stack;
            }
        };
        
        function getAgentTypeName(typeValue) {
            for (const [key, value] of Object.entries(AgentType)) {
                if (typeof value === 'number' && value === typeValue) {
                    return key;
                }
            }
            return 'UNKNOWN';
        }
    </script>
</body>
</html>